"""
Scenario and Response Endpoints
Handles human-in-the-loop interactions and scenario approval

Client Requirements:
1. Human will enter a reason or multiple reasons with contribution percentages
2. Agent will need to remember what human changed
3. System saves approved scenario to be applied
"""
from fastapi import APIRouter, Depends, HTTPException, status
from app.schemas.request import (
    QuestionResponseRequest,
    ScenarioApprovalRequest
)
from app.schemas.response import (
    QuestionResponseResponse,
    ScenarioApprovalResponse,
    SessionStatusResponse,
    StorageStatsResponse
)
from app.api.deps import get_current_user
from app.services.session_storage import session_storage
from app.utils.helpers import get_current_timestamp
import logging

logger = logging.getLogger(__name__)

router = APIRouter()


@router.post("/response", response_model=QuestionResponseResponse)
async def submit_question_response(
    request: QuestionResponseRequest,
    current_user: dict = Depends(get_current_user)
):
    """
    Submit a response to a question from the forecast analysis.

    This endpoint allows users to answer questions generated by the agent,
    such as:
    - How to handle large POs
    - Whether to adjust forecasts after variances
    - Confirmation of project delays

    The response is stored for:
    1. Immediate decision tracking
    2. Future agent learning (to improve recommendations)
    """
    try:
        logger.info(f"Received response for session {request.session_id}, question {request.question_id}")

        # Verify session exists
        session = session_storage.get_session(request.session_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Session {request.session_id} not found"
            )

        # Validate reason code percentages sum to 100 if provided
        if request.reason_codes:
            total_percent = sum(rc.percent for rc in request.reason_codes)
            if total_percent != 100:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Reason code percentages must sum to 100, got {total_percent}"
                )

        # Store the response
        stored_response = session_storage.store_response(
            session_id=request.session_id,
            question_id=request.question_id,
            response_value=request.response_value,
            reason_codes=[rc.model_dump() for rc in request.reason_codes],
            notes=request.notes
        )

        logger.info(f"Stored response: {request.response_value} for question {request.question_id}")

        return QuestionResponseResponse(
            session_id=request.session_id,
            question_id=request.question_id,
            response_value=request.response_value,
            status="recorded",
            message=f"Response recorded successfully for question {request.question_id}",
            timestamp=get_current_timestamp()
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error storing response: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error storing response: {str(e)}"
        )


@router.post("/approve", response_model=ScenarioApprovalResponse)
async def approve_scenario(
    request: ScenarioApprovalRequest,
    current_user: dict = Depends(get_current_user)
):
    """
    Approve and apply a selected scenario.

    This is the final step in the forecast review process where the user:
    1. Selects one of the generated scenarios
    2. Provides reason codes with percentages
    3. Optionally adds notes

    The approved scenario will be:
    1. Stored as the selected forecast revision
    2. Available for Capexplan to retrieve and apply
    3. Saved in forecast history for the project
    """
    try:
        logger.info(f"Approving scenario {request.scenario_id} for session {request.session_id}")

        # Verify session exists
        session = session_storage.get_session(request.session_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Session {request.session_id} not found"
            )

        # Validate reason code percentages sum to 100
        total_percent = sum(rc.percent for rc in request.reason_codes)
        if total_percent != 100:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Reason code percentages must sum to 100, got {total_percent}"
            )

        # Find the selected scenario
        scenarios = session.get('scenarios', [])
        selected_scenario = next(
            (s for s in scenarios if s['scenario_id'] == request.scenario_id),
            None
        )

        if not selected_scenario:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Scenario {request.scenario_id} not found in session"
            )

        # Store the approval
        approval = session_storage.approve_scenario(
            session_id=request.session_id,
            scenario_id=request.scenario_id,
            reason_codes=[rc.model_dump() for rc in request.reason_codes],
            notes=request.notes
        )

        # Store in forecast history
        project_id = session.get('project', {}).get('id', 'unknown')
        session_storage.store_forecast_history(
            project_id=project_id,
            forecasts=selected_scenario.get('forecasts', []),
            revision_type='human_approved'
        )

        logger.info(f"Scenario {request.scenario_id} approved and stored for project {project_id}")

        # Build next steps based on scenario
        next_steps = [
            "Review the approved forecasts in Capexplan",
            "Monitor actuals against new forecasts",
            "Schedule follow-up review if variances continue"
        ]

        if selected_scenario.get('variance_from_budget', 0) > 0:
            next_steps.insert(0, "Consider requesting budget increase if variance is significant")

        return ScenarioApprovalResponse(
            session_id=request.session_id,
            scenario_id=request.scenario_id,
            scenario_name=selected_scenario.get('name', 'Unknown'),
            status="approved",
            approved_forecasts=selected_scenario.get('forecasts', []),
            total_year_forecast=selected_scenario.get('total_year_forecast', 0),
            variance_from_budget=selected_scenario.get('variance_from_budget', 0),
            reason_codes=[rc.model_dump() for rc in request.reason_codes],
            message=f"Scenario '{selected_scenario.get('name')}' approved successfully",
            timestamp=get_current_timestamp(),
            next_steps=next_steps
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error approving scenario: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error approving scenario: {str(e)}"
        )


@router.get("/session/{session_id}", response_model=SessionStatusResponse)
async def get_session_status(
    session_id: str,
    current_user: dict = Depends(get_current_user)
):
    """
    Get the status of a session including all responses and approvals.

    This endpoint allows users to:
    1. Check the current state of a forecast review session
    2. See all responses submitted
    3. See if a scenario has been approved
    """
    try:
        session = session_storage.get_session(session_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Session {session_id} not found"
            )

        responses = session_storage.get_responses(session_id)
        approved = session_storage.get_approved_scenario(session_id)

        # Determine status
        if approved:
            status_text = "approved"
        elif responses:
            status_text = "in_progress"
        else:
            status_text = "pending"

        project = session.get('project', {})

        return SessionStatusResponse(
            session_id=session_id,
            request_id=session.get('request_id', ''),
            project_id=project.get('id', ''),
            project_name=project.get('name', ''),
            status=status_text,
            responses=responses,
            approved_scenario=approved,
            created_at=session.get('stored_at', session.get('timestamp', '')),
            last_updated=approved.get('approved_at') if approved else (
                responses[-1]['timestamp'] if responses else session.get('stored_at', '')
            )
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting session status: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting session status: {str(e)}"
        )


@router.get("/history/{project_id}")
async def get_forecast_history(
    project_id: str,
    current_user: dict = Depends(get_current_user)
):
    """
    Get forecast revision history for a project.

    Client Requirement:
    "Each column is saved in buffer. At the end of the year we will have many columns."

    This endpoint returns all forecast revisions stored for a project,
    allowing comparison between original and revised forecasts.
    """
    try:
        history = session_storage.get_forecast_history(project_id)

        if not history:
            return {
                "project_id": project_id,
                "message": "No forecast history found for this project",
                "revisions": []
            }

        return {
            "project_id": project_id,
            "total_revisions": len(history),
            "revisions": history
        }

    except Exception as e:
        logger.error(f"Error getting forecast history: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting forecast history: {str(e)}"
        )


@router.get("/stats", response_model=StorageStatsResponse)
async def get_storage_stats(
    current_user: dict = Depends(get_current_user)
):
    """
    Get storage statistics (admin/debug endpoint).

    Returns counts of sessions, responses, and approvals stored.
    """
    stats = session_storage.get_stats()
    return StorageStatsResponse(**stats)


@router.get("/learning-data")
async def get_learning_data(
    limit: int = 100,
    current_user: dict = Depends(get_current_user)
):
    """
    Get data for agent learning from human responses.

    Client Requirement:
    "Agent will need to remember what human changed during the monthly forecast
    and use it to improve the process in the next month"

    This endpoint returns historical data about:
    - What flags were raised
    - What scenarios were generated
    - How humans responded
    - Which scenarios were approved

    This data can be used to train/improve the agent's recommendations.
    """
    try:
        learning_data = session_storage.get_learning_data(limit)

        return {
            "total_records": len(learning_data),
            "learning_data": learning_data,
            "message": "Use this data to analyze human decision patterns and improve recommendations"
        }

    except Exception as e:
        logger.error(f"Error getting learning data: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting learning data: {str(e)}"
        )
